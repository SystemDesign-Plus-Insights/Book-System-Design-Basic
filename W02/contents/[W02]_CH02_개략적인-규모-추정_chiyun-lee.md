# 2장

## 개략적인 규모 추정

- 2의 제곱수
    - 시스템의 최소 단위 : 1byte = 8bit = 2^3bit
    - 2^10: 1천, 2^20: 1백만, 2^30: 10억, …

- 응답지연(latency) 값
    - 메모리 탐색은 빠르다, 디스크는 느리다
    - 디스크 탐색은 가능한 피하자
    - 단순한 압축 알고리즘은 빠르다
    - 데이터를 인터넷으로 전송하기 전에 가능하면 압축하라
    - 데이터 센터는 여러 지역(위치)에 분산되어 있어, 센터들간의 데이터 통신에도 시간이 걸린다.

- 가용성에 관계된 수치
    
    고가용성(high availability)은 시스템이 오랜 시간 동안 지속적으로 중단 없이 운영될 수 있는 능력을 저장하는 용어.
    
    - ‘%’ 로 나타내며, 100% ⇒ 시스템이 단 한 번도 중단된 적 없었음을 의미.
        - 대부분의 서비스는 99% ~ 100%
    - SLA(Service Level Agreement) : 서비스 사업자(service provider)가 보편적으로 사용하는 용어
    
     
    

### 트위터로 알아보는 QPS와 저장소 요구량 추정

- **가정**
    - 월간 능동 사용자: 3억 명
    - 50% 사용자가 트위터를 매일 사용
    - 평균적으로 각 사용자는 매일 2건의 트윗
    - 미디어를 포함하는 트윗은 10% 정도
    - 데이터는 5년간 보관
- **추정**
    - QPS(Query Per Second)
        - 매일 1.5억명 정도 트위터 사용 (3억 * 50%) ⇒ DAU(Daily Active User) 일간 능동 사용자
        - QPS = 1.5억 x 2트윗 / 24시간 / 3600초 = 약 3500 ⇒ 초당 쿼리 발생량
        - 최대 QPS = 3500 x 2 = 7000 ⇒ 모든 사용자가 사용하는 경우
        
        - 미디어 저장을 위한 저장소 요구량
            - 평균 트윗 크기
                - tweet_id : 64byte
                - text : 140byte
                - 미디어 : 1MB
            - 미디어 저장소 요구량 : 1.5억 x 2 x 10% x 1MB = 30TB / 일
            - 5년간 미디어를 보관하기 위한 저장소 요구량 : 30TB x 365 x 5 = 약 55PB

### 팁

- 결과도 중요하지만, 결과를 도출한 과정(논리)이 중요하다
- 근사치 계산
    - 99987 / 9.1 ⇒ 100000 / 10
- 가정을 적어두자 (계산의 근거)
- 단위는 필수 (MB, %, …)
- QPS, 최대 QPS, 저장소 요구량, 캐시 요구량, 서버 수 등을 추정할 줄 알아야한다.

 

### 모르겠는 부분

DB I/O 디스크 탐색

- 캐시 : Redis, Memcached
- 데이터 베이스 단에서 인덱스 최적화
- 배치 처리
- Lazy Loading
- Disk I/O Scheduling
- 데이터 압축(Spring Data JPA와 GZIP사용)

MySQL에서 SQL을 사용하여 데이터를 가져오는 과정은 일반적으로 다음과 같은 단계를 거칩니다:

1. 클라이언트(애플리케이션)가 MySQL 서버로 SQL 쿼리를 전송합니다.
2. MySQL 서버는 쿼리를 받아 파싱하고 최적화합니다.
3. 최적화된 쿼리 실행 계획에 따라, MySQL은 필요한 데이터를 찾기 위해 스토리지 엔진과 상호 작용합니다.
4. 스토리지 엔진(기본값은 InnoDB)은 디스크에서 필요한 데이터를 읽어옵니다. 이 때, MySQL은 버퍼 풀(메모리 내 캐시)을 활용하여 디스크 I/O를 최소화하려고 합니다.
    - 버퍼 풀에 필요한 데이터가 이미 존재하면, 디스크에서 읽지 않고 메모리에서 직접 데이터를 가져옵니다.
    - 버퍼 풀에 데이터가 없으면, 디스크에서 데이터를 읽어와 버퍼 풀에 캐시하고, 이를 반환합니다.
5. 스토리지 엔진이 필요한 데이터를 찾아 MySQL 서버로 반환합니다.
6. MySQL 서버는 받은 데이터를 추가로 처리하고(정렬, 그룹화, 집계 등), 최종 결과를 클라이언트에게 전달합니다.

따라서 SQL로 데이터를 가져오는 과정에서 디스크 I/O가 발생할 수 있지만, MySQL의 버퍼 풀을 효과적으로 활용하면 디스크 I/O를 최소화할 수 있습니다. frequently accessed data의 경우 버퍼 풀에 캐시되어 있어, 디스크에서 다시 읽어올 필요 없이 메모리에서 직접 데이터를 가져올 수 있습니다.

하지만 대량의 데이터를 처리하거나, 버퍼 풀 크기를 초과하는 데이터를 다룰 때는 디스크 I/O가 발생할 수밖에 없습니다. 이런 경우 쿼리 최적화, 인덱스 사용, 파티셔닝 등의 기술을 활용해 디스크 I/O를 최소화하려고 합니다.
# 6장. 키-값 저장소 설계

### 키-값 저장소

- 비 관계형 데이터베이스
- 고유 식별자 Key (유일성)
    - 일반 텍스트 키: “last_logged_in_at”
    - 해시 키: 253DDEC4
- **예시**
    - 아마존 다이나모
    - memcached
    - 레디스

## 1. 문제 이해 및 설계 범위 확정

- 완벽한 설계란 없다. (답은 없다!)
- 읽기, 쓰기 그리고 메모리 사용량 사이에 어떤 균형을 찾고, 데이터 일관성과 가용성 사이에서 프로젝트에 알맞는 설계

- **요구사항**
    - 키-값 쌍의 크기는 10KB 이하
    - 큰 데이터를 저장할 수 있어야 한다.
    - 높은 가용성 제공 ⇒ 시스템에 장애가 있더라도 빠르게 응답
    - 높은 규모 확장성 ⇒ 트래픽 양에 따라 자동적으로 서버 증설/삭제 필요
    - 데이터 일관성 수준 조정 가능
    - 짧은 응답 지연시간

### 단일 서버 키-값 저장소

- 가장 쉬운 방법은 하나의 해시 테이블에 모든 키-값 데이터를 저장하는것
- 모든 데이터를 메모리 안에 두는 것은 불가능
    - 해결책
        - 데이터 압축
        - 자주 쓰이는 데이터만 메모리에 두고 나머지는 디스크에 저장

### 분산 키-값 저장소

- 분산 해시 테이블
- 키-값 쌍을 여러 서버에 분산

- **CAP 정리**
    - 데이터 일관성, 가용성, 파티션 감내를 모두 만족하는 분산 시스템 설계는 불가능하다는 원칙
    
    - **데이터 일관성**
        - 분산 시스템에 접속하는 모든 클라이언트는 어떤 노드에 접속했느냐에 관계없이 언제나 같은 데이터를 본다.
    - **가용성**
        - 일부에 장애가 발생해도 항상 응답을 받을 수 있다.
    - **파티션 감내**
        - 파티션: 두 노드 사이에 통신 장애가 발생
        - 네트워크에 파티션이 생기더라도 시스템은 계속 동작

- CA, CP, AP: 모두를 만족할 수 없기 때문에 나눈다.

- 파티션은 발생할 수 밖에 없으므로, CA 방식은 허용 X
- 일관성을 유지하기 위해서는 문제가 발생했을 때, 쓰기 처리를 막아야한다.
    - 은행권에서는 일관성이 중요

- 널리 사용하는 키-값 저장소
    - 다이나모, 카산드라, 빅테이블

- **데이터 파티션**
    - 안정 해시 방식을 사용한다.
        - 해시 링을 활용해 서버와 같은 위치에 해시 테이블을 배치한다.
    - **장점**
        - 규모 확장 자동화: 시스템 부하에 따라 서버가 자동으로 추가, 삭제됨
        - 다양성: 각 서버의 용량에 맞게 가상 노드를 조정한다.

- **데이터 다중화**
    - 데이터 사본을 같은 물리 서버에 저장할 경우 가용성을 해친다.

- **데이터 일관성**
    - W(write), R(read), N(사본 수)으로 일관성 파악
        - R=1, W=N: 빠른 읽기 연산 최적화 시스템
        - W=1, R=N: 빠른 쓰기 연산 최적화 시스템
        - W + R > N: 강한 일관성이 보장됨 (보통 N=3, W=R=2)
        - W + R ≤ N: 일관성 보장이 어려움

- 강한 일관성: 모든 읽기 연산이 가장 최근 결과 반영
    - 일반적으로 모든 사본에 현재의 쓰기 연산이 반영하기 전까지 읽기/쓰기 연산 금지
- 약한 일관성: 읽기 연산이 최근 결과를 반영하지 못할 수 있다.
- 결과적 일관성: 결국에는 최신 데이터로 동기화
    - 다이나모, 카산드라가 채택

- 일관성을 해결하기 위해 결과적으로, **클라이언트 처리** 필요

- 데이터를 다중화하면 가용성은 높아지지만, 사본 간 일관성이 깨질 가능성은 높아진다.
- 해결법
    - **데이터 버저닝**
        - 데이터를 변경할 때마다, 해당 데이터의 새로운 버전을 만드는 것
        - **문제상황**
            - 동시에 데이터가 변경 될때 충돌 발생
    - 벡터 시계
        - 같은 서버의 데이터의 버전 번호가 다르면, 충돌 O
        - 클라이언트에서 처리하기에 로직이 복잡하고, 많은 순서쌍이 생기는 문제가 있다.

- **장애 처리**
    - 대규모 분산 시스템에서 장애는 항상 발생
    - 장애 감지 → 장애 해소

- **장애 감지**
    - 서버 하나에 장애가 발생해도, 바로 장애 처리를 하지 않음 (2개 이상의 서버에서 장애를 감지한 경우 처리)
    - **감지 방법**
        - **각 노드는 멤버십 목록에 박동 카운터**를 정해, 일정값 갱신 되지 않는 멤버를 장애 상태로 감지

- **장애 처리**
    - **일시적 장애 처리**
        - 임시 위탁 기법
            - 안정 해시 기법으로 장애가 나지 않은 서버가 대신 읽기/쓰기를 수행 후 임시 서버에 저장하다가 원래 서버가 정상으로 돌아오면 일관성을 유지한다.
    - **영구 장애 처리**
        - 반-엔트로피 프로토콜 구현
            -
# 문제 이해 및 설계 범위 확정

- 파일 추가, 다운로드, 동기화
- 파일 갱신 이력 조회(revision history)
- 파일 공유
- 편집 혹은 삭제 시 알림 표시

# 개략적 설계안 제시 및 동의 구하기

### 개략적 추정치

- 가입 사용자 5천만명 (천만명의 DAU)
- 모든 사용자 10GB 무료 저장공간
- 매일 각 사용자 평균 2개 파일 업로드 (파일의 평균 크기 500KB)
- read:write 1:1
- 필요한 저장공간 = 5천만 사용자 x 10GB = 500페타바이트
- 업로드 API QPS = 약 240
- 480

### API

- 파일 업로드 API
    - 단순 업로드
        - 파일 크기가 작을 때
    - 이어 올리기
        - 파일 크기 클 때 사용

- 파일 다운로드 API

- 파일 갱신 히스토리 API
    - path, limit

### 동기화 충돌

![image](https://github.com/user-attachments/assets/9b914005-bf78-49b6-9cfc-c5dd0bc29ab5)

두 명 이상의 사용자가 동시에 업데이트하려고 하는 경우, 

먼저 처리되는 변경은 성공한 것으로 보고, 나중에 처리되는 변경은 충돌이 발생한 것으로 표시

### 개략적 설계안

![image](https://github.com/user-attachments/assets/37cdb0c9-9dc4-4bb8-88d1-53085613fae7)

- `블록 저장소 서버`
    - 파일 블록을 클라우드 저장소에 업로드하는 서버
    - 파일을 여러 개의 블록으로 나눠 저장한다.
    - 각 블록에는 해시값 할당, 해시값은 메타데이터 DB에 저장된다.
    - 각 블록은 독립적인 객체로 취급되며, 파일을 재구성하려면 블록들을 원래 순서대로 합쳐야 한다.
- `클라우드 저장소`
    - 파일은 블록 단위로 나눠져 클라우드 저장소에 보관
- `아카이빙 저장소(cold storage)`
    - 오랫동안 사용되지 않은 비활성(inactive)데이터를 저장하기 위한 컴퓨터 시스템
- `API 서버`
    - 파일 업로드 외에 모든 것을 담당하는 서버
    - **사용자 인증, 사용자 프로파일 관리, 파일 메타데이터 갱신** 등에 사용
- `메타데이터 DB`
    - 사용자, 파일, 블록, 버전 등의 메타데이터 정보 관리
- 알림 서비스
    - 클라이언트에게 파일 추가, 수정, 삭제를 알림
- 오프라인 사용자 백업 큐(offline backup queue)
    - 클라이언트가 접속 중이 아니라서 파일 최신 상태를 확인할 수 없을 때는 해당 정보를 이 큐에 두어 나중 클라이언트가 접속했을 때 동기화될 수 있도록 한다.

# 상세 설계

### 블록 저장소 서버

큰 파일들은 업데이트가 일어날 때마다 **네트워크 대역폭을 많이 잡아먹게 된다.**

이를 최적화하는 방법으로 두 가지 정도 있다.

- `델타 동기화(delta sync)`
    - 파일이 수정되면 전체 파일 대신, 수정이 일어난 블록만 동기화하는 것이다.
- `압축(compression)`
    - 블록 단위로 압축해 두면 데이터 크기를 많이 줄일 수 있다.

![image](https://github.com/user-attachments/assets/163f716e-8244-48ec-aa04-7cb092cbeab0)

- 파일을 작은 블록들로 분할한다.
- 각 블록을 압축하고 암호화한다.
- s3로 전송한다.

### 높은 일관성 요구사항

이 시스템은 강한 일관성(strong consistency)모델을 기본으로 지원해야 한다. 항상 가장 최신의 데이터를 반환할 필요가 있기 때문이다.

메모리 캐시는 보통 **결과적 일관성(eventual consistency)모델**을 지원하므로, 강한 일관성을 위해 다음 사항을 보장해야 한다.

- 캐시에 보관된 사본과 데이터베이스에 있는 원본(master)이 일치한다.
- DB에 보관된 원본에 변경이 발생하면 캐시에 있는 사본을 무효화한다.

RDB는 ACID를 보장하므로 강한 일관성을 보장하기 쉽다.

NoSQL는 동기화 로직 안에 프로그래밍해야 한다.

### 업로드 절차

아래 시퀀스는 두 개 요청이 병렬적으로 전송된 상황을 보여준다.

![image](https://github.com/user-attachments/assets/2e682292-440d-4c44-a1c2-1bc1376e8a85)

### 다운로드 절차

![image](https://github.com/user-attachments/assets/1a4accb4-2516-4110-ac0b-80213e044290)

### 알림 서비스

파일 일관성 유지를 위해, Client는 로컬에서 파일이 수정되었음을 감지하는 순간, 다른 클라이언트에 그 사실을 알려 충돌 가능성을 줄여야 한다.

- long polling
- WebSocket

채팅과 같이 양방향 통신이 필요하지 않으므로, 롱 폴링 사용

Client는 알림 서버와 Long Polling용 연결을 유지하다가 특정 파일에 대한 변경을 감지하면 해당 연결을 끊는다.

Clinet는 메타데이터 서버와 연결해 최신 파일을 다운로드 한 후, 새로운 롱 폴링 요청을 보낸다.

### 저장소 공간 절약

- 중복 제거(de-deupe)
    - 중복된 파일 블록을 계정 차원에서 제거(해시 값 비교로 판단)
- 지능적 백업 전략
    - 한도 설정: 보관해야 하는 파일 버전 개수 상한을 둔다.
    - 중요한 버전만 보관
- 자주 쓰이지 않는 데이터는 아카이빙 저장소(cold storage)로 옮긴다

### 장애 처리

- 로드밸런서 장애
    - 로드밸런서 장애가 발생할 경우 부(secondary) 로드밸런서가 활성화되어 트래픽을 이어받는다.
    - 로드밸런서 끼리는 박동(heartbeat) 신호를 보내서 상태를 모니터링한다.
- 메타데이터 캐시 장애
    - 캐시 서버도 다중화한다.
- 메타데이터 DB 장애
    - Master 장애: Slave 가운데 하나를 Master로 승격 후, Slave 추가
    - Slave 장애: 다른 Slave가 읽기 연산 처리, 그동안 장애 Slave 교체
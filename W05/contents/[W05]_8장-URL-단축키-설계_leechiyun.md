# 8장. URL 단축키 설계

## 1단계. 문제 이해 및 설계 범위 확정

- **요구사항**
    - [https://www.a.com/q=chatsystem&c=loggedin&v=v3](https://www.a.com/q=chatsystem&c=loggedin&v=v3) → [https://tinyurl.com](https://www.a.com/q=chatsystem&c=loggedin&v=v3)/${hash}
    - 단축 url을 클릭해도 원본으로 갈 수 있어야한다.
    - 트래픽 규모: 매일 1억
    - 단축 URL 길이: 짧으면 짧을수록 좋다.
    - 포함 문자: 0~9, a~z, A~Z
    - 단축 URL 삭제, 갱신은 단순화를 위해 제거

- **시스템 기본적 기능**
    - URL 단축: 주어진 URL 길이를 줄인다.
    - URL 리다이렉션(redirection): 축약된 URL로 HTTP 요청이 오면 원래 URL로 안내
    - 높은 가용성, 규모 확장성, 그리고 장애 감내가 요구

- **개략적 추정**
    - 쓰기 연산: 매일 1억개의 단축 URL
    - 읽기 연산: 쓰기 연산의 10배로 가정
    - 보관: 10년간 보관한다 가정: 1억 x 365 x 10
    - 축약전 평균 URL 크기: 100
    - 저장 용량: 보관 시간 x 평균 URL 크기

## 2단계. 개략적 설계안 제시 및 동의 구하**기**

- **API 엔드포인트**
    - 클라이언트는 서버가 제공하는 API 엔드포인트를 통해 서버와 통신
    - RESTful API
        1. URL 단축용 엔드포인트
            - URL을 통해 단축 URL 생성 (POST 요청)
            - **POST /api/v1/data/shorten**
                - 인자: {longUrl: longUrlString}
                - return: 단축 URL
        2. URL 리다이렉션용 엔드포인트
            - 단축 URL에 대해서 HTTP 요청이 오면 원래 URL로 보내주기 위한 용도의 엔드포인트
            - **GET /api/v1/shortUrl**
                - return: HTTP 리다이렉션 목적지가 될 원본 URL

- **URL 리다이렉션**
    - 301 응답의 Location 헤더에 원래 URL로 바꾸어 return
    - HTTP 응답
        - 301 Permanently Moved
            - 영구적으로 Location 헤더에 반환된 URL로 이전됨을 알림, 캐시사용
            - 서버 부하를 줄임
        - 302 Found
            - 일시적, 항상 서버에 요청을 보내 원래 URL 응답을 받음
            - 트래픽 분석이 중요할 때
    - 단축 URL을 key (Map<단축 URL, 원본 URL>
        - 있으면, 기존 데이터로 원본 URL 반환
        - 없으면, 서버에 GET 요청
        
- **URL 단축**
    - 원본 URL 해시 함수를 찾는게 중요
        - 해시값은 충돌 X (중복 X)
        - 원본 URL 해시 값은 언제나 같다.

## 3단계. 상세 설계

- **데이터 모델**
    - 해시 테이블을 메모리에 저장하면 비용이 크다
        - <단축 URL, 원본 URL>의 순서쌍을 가진 관계형 DB에 저장

- **해시 함수**
    - 원래 URL ⇒ 단축 URL (hashValue)
    - **해시 값 길이**
        - 62^7 = 3.5조개 생성 가능
        - 함수 구현
            - **해시 후 충돌 해소.**
                - 7글자의 해시 값을 생성하기 위해선 기존 CRC32, MD5, SHA-1 같이 잘 알려진 해시 함수를 이용
                - 해시 함수로 인해 긴 해시 길이를 가지면, 앞의 7글자만 사용
                    - 충돌 발생
                        - DB에 데이터가 있으면, 기존 해시값에 특정 문자열을 추가하는 것으로 해결 (오버헤드 큼)
                        - 블룸 필드 사용
                            - 블룸 필터는 어떤 집합(Set)에 특정 원소가 있는지 검사
            - **base-62 변환**
                - character(문자)는 62
                - 10진법(id) → 62진법으로 변환
        - **비교**
            
            
            | 해시 후 충돌 해소 전략 | base-62 변환 |
            | --- | --- |
            | 단축 URL 길이 고정 | 단축 URL의 가변성, ID가 커지면 같이 커짐  |
            | 다른 수단 필요 X | 유일성 보장 ID 생성기 필요 |
            | 충돌 발생 | 해시 충돌 X |
            | URL을 통해 다음에 쓸 수 있는 URL 아는 것이 불가능 | ID를 통해 다음 해시 값 유추 가능(보안 문제) |

- **URL 단축키 상세 설계**
    1. 원본 URL 입력
    2. DB에서 원본 URL이 있는지 확인
        1. 있으면, 단축 URL 바로 return
        2. 없으면, 새로운 ID 생성 (ID 생성기 활용)
    3. 새로운 ID 생성
    4. 생성된 ID를 단축 URL로 변환 (base-62: 62진번 변환)
    5. ID, 단축 URL, 원래 URL을 DB에 저장
    
- **URL 리다이렉션 설계**
    1. 사용자 단축 URL을 클릭
    2. 해당 클릭을 바탕으로 로드밸런서가 웹 서버에 전달
    3. 단축 URL이 이미 캐시에 있는 경우, 원래 URL 바로 클라이언트 전달
    4. 캐시에 해당 단축 URL이 없는 경우, DB에서 전달
    5. DB에서 전달하는 URL을 캐시에 넣는다.

## 4단계. 마무리

- **처리율 제한 장치**
    - 단축 요청이 몰릴 경우 해결
    
- **웹 서버의 규모 확장**
    - Web = HTTP는 무상태성
    - 웹 서버를 자유로이 증설, 삭제 가능
    - **근거**
        - **무상태성의 개념**
            - HTTP는 무상태 프로토콜로, 각 요청(Request)은 독립적으로 처리됩니다.
            - 서버는 이전 요청에 대한 정보를 유지하지 않으며, 각 요청은 필요한 모든 정보를 포함하고 있어야 합니다.
            - 서버는 클라이언트의 상태를 저장하지 않으므로 서버의 부하를 줄일 수 있습니다.
        - **서버의 확장성**
            - 무상태성은 서버의 확장성을 높이는 데 큰 역할을 합니다.
            - 각 요청이 독립적으로 처리되므로 요청을 처리하는 서버의 선택이 자유롭습니다.
            - 로드 밸런서를 사용하여 요청을 여러 서버에 분산시킬 수 있습니다.
            - 서버의 증설이나 삭제가 용이해지며, 서버 간의 상태 동기화가 필요하지 않습니다.
        - **서버의 무중단 운영**
            - 무상태성은 서버의 무중단 운영을 가능하게 합니다.
            - 서버의 일부가 고장 나더라도 다른 서버에서 요청을 처리할 수 있습니다.
            - 서버의 유지보수나 업그레이드 시에도 서비스의 중단 없이 작업을 진행할 수 있습니다.
        - **캐싱의 활용**
            - 무상태성은 캐싱을 효과적으로 활용할 수 있게 합니다.
            - 동일한 요청에 대한 응답을 캐시에 저장하고 재사용할 수 있습니다.
            - 서버의 부하를 줄이고 응답 속도를 향상시킬 수 있습니다.
        - **상태 관리의 한계**
            - 무상태성은 상태 관리에 제한이 있음을 의미합니다.
            - 사용자 인증, 장바구니 등의 상태 정보는 클라이언트 측에서 관리해야 합니다.
            - 세션, 쿠키, 토큰 등의 방법을 사용하여 클라이언트 측에서 상태를 유지할 수 있습니다.

- **DB 규모 확장**
    - **DB 다중화(Database Replication)**
        - DB 다중화는 동일한 데이터를 여러 개의 데이터베이스 서버에 복제하는 기술입니다.
        - 주 데이터베이스(Master)와 하나 이상의 복제 데이터베이스(Slave)로 구성됩니다.
        - 주 데이터베이스에서 수행된 변경 사항은 복제 데이터베이스에 실시간으로 반영됩니다.
        - 읽기 작업은 복제 데이터베이스에 분산되어 처리될 수 있습니다.
        - 다중화를 통해 읽기 성능을 향상시키고 데이터의 가용성을 높일 수 있습니다.
        - 주 데이터베이스에 장애가 발생해도 복제 데이터베이스를 사용하여 서비스를 계속 제공할 수 있습니다.
        - MySQL의 Replication, PostgreSQL의 Streaming Replication 등이 대표적인 DB 다중화 기술입니다.
    - **샤딩(Sharding)**
        - 샤딩은 대규모 데이터를 여러 개의 데이터베이스 서버에 분산 저장하는 기술입니다.
        - 데이터를 샤드(Shard)라는 작은 단위로 나누어 독립적인 데이터베이스 서버에 저장합니다.
        - 각 샤드는 데이터의 일부분을 담당하며, 샤드 간에는 데이터가 중복되지 않습니다.
        - 샤딩을 통해 데이터를 수평적으로 확장(Scale-out)할 수 있습니다.
        - 샤딩은 데이터의 양이 매우 크거나 읽기/쓰기 작업이 많은 경우에 유용합니다.
        - 샤딩은 데이터의 분산으로 인해 복잡한 쿼리나 조인 작업이 어려워질 수 있습니다.
        - 샤딩 키(Sharding Key)를 기준으로 데이터를 분할하며, 샤딩 키 선정이 중요합니다.
        - MongoDB의 Sharding, Cassandra의 Partitioning 등이 대표적인 샤딩 기술입니다.

- **데이터 분석 솔루션**
    - 비즈니스를 위한 데이터 분석 필요
        - 얼마나 많은 사용자가 어떤 링크 클릭
        - 언제 주로 클릭

- **가용성, 일관성, 안정성 유지**